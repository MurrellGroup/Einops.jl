var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Patterns","page":"API","title":"Patterns","text":"","category":"section"},{"location":"api/#Einops.ArrowPattern","page":"API","title":"Einops.ArrowPattern","text":"ArrowPattern{L,R}\n\nA pair of tuples representing the left and right sides of a rearrange/reduce/repeat pattern. These tuples are stored as type parameters, such that the pattern is known at compile time.\n\nAn instance ArrowPattern{L,R}() gets shown as L --> R, as --> is used for construction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Einops.:-->","page":"API","title":"Einops.:-->","text":"-->\n\nCreate an ArrowPattern from a left and right tuple. Non-tuple elements are automatically wrapped in a single-element tuple.\n\nExamples\n\njulia> pattern1 = (:a, :b, :c) --> (:c, (:b, :a)) # nested tuple\n(:a, :b, :c) --> (:c, (:b, :a))\n\njulia> typeof(pattern1)\nArrowPattern{(:a, :b, :c), (:c, (:b, :a))}\n\njulia> pattern2 = :a --> (1, :a) # single-element autoconversion\n(:a,) --> (1, :a)\n\njulia> typeof(pattern2)\nArrowPattern{(:a,), (1, :a)}\n\njulia> (:a, ..) --> :a # exported ellipsis notation\n(:a, EllipsisNotation.Ellipsis()) --> (:a,)\n\n\n\n\n\n","category":"function"},{"location":"api/#Einops.@einops_str","page":"API","title":"Einops.@einops_str","text":"@einops_str -> Union{ArrowPattern,Tuple}\n\nFor parity with Python implementation.\n\nExamples\n\njulia> einops\"a 1 b c -> (c b) a\"\n(:a, 1, :b, :c) --> ((:c, :b), :a)\n\njulia> einops\"embed token (head batch) -> (embed head) token batch\"\n(:embed, :token, (:head, :batch)) --> ((:embed, :head), :token, :batch)\n\njulia> einops\"i j, j k -> i k\" # for einsum\n((:i, :j), (:j, :k)) --> (:i, :k)\n\njulia> einops\"a b _ d\" # for parse_shape\n(:a, :b, -, :d)\n\njulia> einops\"i j * k\" # for pack/unpack\n(:i, :j, *, :k)\n\n\n\n\n\n","category":"macro"},{"location":"api/#parse_shape","page":"API","title":"parse_shape","text":"","category":"section"},{"location":"api/#Einops.parse_shape","page":"API","title":"Einops.parse_shape","text":"parse_shape(x, pattern)\n\nCapture the shape of an array in a pattern by naming dimensions using Symbols, and - to ignore dimensions.\n\nExamples\n\njulia> parse_shape(rand(2,3,4), (:a, :b, -))\n(a = 2, b = 3)\n\njulia> parse_shape(rand(2,3), (-, -))\nNamedTuple()\n\njulia> parse_shape(rand(2,3,4,5), (:first, :second, :third, :fourth))\n(first = 2, second = 3, third = 4, fourth = 5)\n\n\n\n\n\n","category":"function"},{"location":"api/#rearrange","page":"API","title":"rearrange","text":"","category":"section"},{"location":"api/#Einops.rearrange","page":"API","title":"Einops.rearrange","text":"rearrange(array::AbstractArray, left --> right; context...)\nrearrange(arrays, left --> right; context...)\n\nRearrange the axes of x according to the pattern specified by left --> right.\n\nCan always be expressed as a reshape + permutedims + reshape.\n\nExamples\n\njulia> x = rand(2,3,5);\n\njulia> y = rearrange(x, (:a, :b, :c) --> (:c, :b, :a));\n\njulia> size(y)\n(5, 3, 2)\n\njulia> y == permutedims(x, (3,2,1))\ntrue\n\njulia> z = rearrange(x, (:a, :b, :c) --> (:a, (:c, :b)));\n\njulia> size(z)\n(2, 15)\n\njulia> z == reshape(permutedims(x, (1,3,2)), 2,5*3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#reduce","page":"API","title":"reduce","text":"","category":"section"},{"location":"api/#Base.reduce","page":"API","title":"Base.reduce","text":"reduce(f::Function, x::AbstractArray, left --> right; context...)\n\nReduce an array over the dimensions specified by the pattern, using e.g. sum, prod, minimum, maximum, any, all, or Statistics.mean.\n\nf must accept a dims::Tuple{Vararg{Int}} keyword argument, allowing for reduction over specific dimensions. This should reduce the specified dimensions to singletons, but not drop them.\n\nnote: Note\nThis method is not meant for binary reduction operations like +, *, min, max, |, &, etc., as would be expected from Base.reduce. Also note that Python's min and max are available in Julia as minimum and maximum respectively.\n\nExamples\n\njulia> x = randn(35, 32, 64);\n\njulia> y = reduce(sum, x, (:t, :b, :c) --> (:b, :c));\n\njulia> size(y)\n(32, 64)\n\njulia> y == dropdims(sum(x, dims=1), dims=1)\ntrue\n\njulia> using Statistics: mean\n\njulia> z = reduce(mean, x, ((:t, :t5), :b, :c) --> (:b, (:c, :t5)), t5=5);\n\njulia> size(z)\n(32, 320)\n\njulia> z == reshape(permutedims(dropdims(mean(reshape(x, 7,5,32,64), dims=1), dims=1), (2,3,1)), 32,320)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#repeat","page":"API","title":"repeat","text":"","category":"section"},{"location":"api/#Base.repeat","page":"API","title":"Base.repeat","text":"repeat(x::AbstractArray, left --> right; context...)\n\nRepeat elements of x along specified axes.\n\nExamples\n\njulia> x = rand(2,3);\n\njulia> y = repeat(x, (:a, :b) --> (:a, :b, 1, :r), r=2);\n\njulia> size(y)\n(2, 3, 1, 2)\n\njulia> y == reshape(repeat(x, 1,1,2), 2,3,1,2)\ntrue\n\njulia> z = repeat(x, (:a, :b) --> (:a, (:b, :r)), r=2);\n\njulia> size(z)\n(2, 6)\n\njulia> z == reshape(repeat(x, 1,1,2), 2,6)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#einsum","page":"API","title":"einsum","text":"","category":"section"},{"location":"api/#Einops.einsum","page":"API","title":"Einops.einsum","text":"einsum(arrays..., (left --> right))\n\nCompute the einsum operation specified by the pattern.\n\nExamples\n\njulia> x, y = rand(2,3), rand(3,4);\n\njulia> einsum(x, y, ((:i, :j), (:j, :k)) --> (:i, :k)) == x * y\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#pack-and-unpack","page":"API","title":"pack and unpack","text":"","category":"section"},{"location":"api/#Einops.pack","page":"API","title":"Einops.pack","text":"pack(unpacked_arrays, pattern)\n\nPack a vector of arrays into a single array according to the pattern.\n\nExamples\n\njulia> inputs = [rand(2,3,5), rand(2,3,7,5), rand(2,3,7,9,5)];\n\njulia> packed_array, packed_shapes = pack(inputs, (:i, :j, *, :k));\n\njulia> size(packed_array)\n(2, 3, 71, 5)\n\njulia> packed_shapes\n3-element Vector{NTuple{N, Int64} where N}:\n ()\n (7,)\n (7, 9)\n\n\n\n\n\n","category":"function"},{"location":"api/#Einops.unpack","page":"API","title":"Einops.unpack","text":"unpack(packed_array, packed_shapes, pattern)\n\nUnpack a single array into a vector of arrays according to the pattern.\n\nExamples\n\njulia> inputs = [rand(2,3,5), rand(2,3,7,5), rand(2,3,7,9,5)];\n\njulia> inputs == unpack(pack(inputs, (:i, :j, *, :k))..., (:i, :j, *, :k))\ntrue\n\njulia> packed_array = rand(2,3,16);\n\njulia> packed_shapes = [(), (7,), (4, 2)];\n\njulia> unpack(packed_array, packed_shapes, (:i, :j, *)) .|> size\n3-element Vector{Tuple{Int64, Int64, Vararg{Int64}}}:\n (2, 3)\n (2, 3, 7)\n (2, 3, 4, 2)\n\n\n\n\n\n","category":"function"},{"location":"#Einops","page":"Home","title":"Einops","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Einops.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add Einops\"","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"api.md\"\n]","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
